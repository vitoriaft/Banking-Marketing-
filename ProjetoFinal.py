# -*- coding: utf-8 -*-
"""projeto.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CdOQ5kwQq41KGYsEkTPG7t_yMKSkT1sA

## Importando as bibliotecas
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px

"""## Carregando o dataset"""

pd.set_option('display.max_columns', None)

df = pd.read_csv('bank-additional-full.csv', sep = ';')
df

"""## EDA - Exploratory Data Analysis

### Análise Exploratória
"""

df.shape

df.columns

"""Dados do cliente bancário:
- age --> (numérico)
- job --> tipo de trabalho (categórico: 'administrador', 'operário', 'empreendedor', 'empregada doméstica', 'gestão', 'aposentado', 'autônomo', 'serviços', 'estudante', ' técnico', 'desempregado', 'desconhecido')
- marital --> estado civil (categórico: 'divorciado', 'casado', 'solteiro', 'desconhecido'; nota: 'divorciado' significa divorciado ou viúvo)
- education --> (categórica: 'básico.4a', 'básico.6a', 'básico.9a', 'ensino médio', 'analfabeto', 'curso.profissional', 'grau universitário', 'desconhecido')
- default --> tem crédito em inadimplência? (categórico: 'não', 'sim', 'desconhecido')
- housing --> tem crédito à habitação? (categórico: 'não', 'sim', 'desconhecido')
- loan --> tem empréstimo pessoal? (categórico: 'não', 'sim', 'desconhecido')

Relacionado com o último contato da campanha atual:
- contact --> tipo de comunicação de contato (categórica: 'celular', 'telefone')
- month --> último mês de contato do ano (categórico: 'jan', 'fev', 'mar',…, 'nov', 'dec')
- day_of_week --> último dia de contato da semana (categórico: 'seg','ter','qua','qui','sex')
- duration --> duração do último contato, em segundos (numérico). Nota importante: este atributo afeta fortemente o alvo de saída (por exemplo, se duração=0 então y='não'). No entanto, a duração não é conhecida antes de uma chamada ser realizada. Além disso, após o término da chamada, y é obviamente conhecido. Assim, este input só deve ser incluído para fins de benchmark e
deve ser descartado se a intenção for ter um modelo preditivo realista.

Outros atributos:
- campaign --> quantidade de contatos realizados durante esta campanha e para este cliente (numérico, inclui último contato)
- pdays --> número de dias que se passaram desde que o cliente foi contatado pela última vez em uma campanha anterior (numérico; 999 significa que o cliente não foi contatado anteriormente)
- previous --> número de contatos realizados antes desta campanha e para este cliente (numérico)
- poutcome --> resultado da campanha de marketing anterior (categórica: 'fracasso', 'inexistente', 'sucesso')

Atributos do contexto social e econômico
- emp.var.rate --> taxa de variação do emprego – indicador trimestral (numérico)
- cons.price.idx --> índice de preços ao consumidor - indicador mensal (numérico)
- cons.conf.idx --> índice de confiança do consumidor – indicador mensal (numérico)
- euribor3m --> taxa euribor a 3 meses – indicador diário (numérico)
- nr.employed --> número de empregados – indicador trimestral (numérico)

Variável de saída (alvo desejado):
- y --> o cliente subscreveu um depósito a prazo? (binário: 'sim', 'não')
"""

df.info()

df.isnull().sum()

df.describe()

#transformando a coluna pdays em categórica
for i in range(len(df['pdays'])):
    if df['pdays'][i] == 999:
        df.loc[i, 'pdays'] = 0
    else:
        df.loc[i, 'pdays'] = 1

df['pdays'].unique()

df = df[~df.applymap(lambda x: x in ['unknown']).any(axis=1)]

df.rename(columns={'y': 'adesao'}, inplace=True)

"""### Histogramas

#### Dados Balanceados?
"""

#visualização da quantidade de clientes que vão subscrever um depósito à prazo ou não
fig = plt.subplots(figsize = (9,6))
class_counts = df['adesao'].value_counts()
plt.bar(class_counts.index, class_counts.values, color = "#FF8E00")
for i, count in enumerate(class_counts.values):
    plt.text(i, count, str(count), ha='center', va='bottom')
plt.title('O cliente vai subscever um depósito a prazo?', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.ylabel('Contagem', fontsize = 12, style = "italic", labelpad = 12)
plt.grid()

#porcentagem de cada classe
total_samples = len(df)
percentage_yes = (class_counts['yes'] / total_samples) * 100
percentage_no = (class_counts['no'] / total_samples) * 100

#print das porcentagens
print(f'"yes": {percentage_yes:.2f}%')
print(f'"no": {percentage_no:.2f}%')

"""#### Visualização da Distribuição dos Dados Numéricos"""

df_numbers = df.select_dtypes(exclude=['object'])

df_numbers.hist(figsize=(10, 8), color = '#FF8E00')
plt.tight_layout()

"""#### Visualização da Distribuição dos Dados Categóricos"""

df_strings = df.select_dtypes(['object'])

plt.figure(figsize=(14, 8))
for i, column in enumerate(df_strings.columns):
    plt.subplot(3, 4, i + 1)
    df_strings[column].value_counts().plot(kind='barh', color = '#FF8E00')
    plt.gca().invert_yaxis()
    plt.xticks(rotation=45)
plt.tight_layout()

"""### Correlação entre as Variáveis"""

correlacao = df_numbers.corr()
plt.figure(figsize=(15, 8))
sns.heatmap(correlacao, annot=True, cmap="Oranges")
plt.title('Matriz de Correlação', fontsize = 18, style = "italic", loc = "center", pad = 15)

"""### Análise das Categorias

#### Relação com a variável y

##### Adesão x Idade
"""

color_map = {
    'no': "#FF8E00",
    'yes': "#A64600"}

fig = px.box(df, x="adesao", y="age", color = 'adesao', color_discrete_map = color_map)
fig.update_layout(
    title={
        'text': 'Adesão por Idade',
        'font': {
            'size': 16
        },
        'x': 0.5
    },
    legend_title_text='Aderiu?')
fig.show()

"""##### Subscrição de um Depósito a Prazo x Duração Último Contato"""

fig = px.box(df, x="adesao", y="duration", color = 'adesao', color_discrete_map = color_map)
fig.update_layout(
    title={
        'text': 'Adesão por Tempo de Duração (em seg) do Último Contato',
        'font': {
            'size': 16
        },
        'x': 0.5
    },
    legend_title_text='Aderiu?')
fig.show()

"""##### Adesão x Educação"""

education_y = df.groupby(['education', 'adesao']).size().reset_index(name='count')
education_y

ordem = ['yes', 'no']
education_y['adesao'] = pd.Categorical(education_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (15,4))
sns.barplot(data = education_y, x='education', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesão por Educação', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Educação', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', bbox_to_anchor=(1.08, 1), fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_educacao.png", dpi=300, facecolor='white', bbox_inches='tight')

"""##### Adesão x Estado Civil"""

marital_y = df.groupby(['marital', 'adesao']).size().reset_index(name='count')
marital_y

marital_y['adesao'] = pd.Categorical(marital_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (10,4))
sns.barplot(data = marital_y, x='marital', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesão por Estado Civil', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Estado Civil', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_estado_civil.png", dpi=300, facecolor='white', bbox_inches='tight')

"""##### Adesão x Emprego"""

job_y = df.groupby(['job', 'adesao']).size().reset_index(name='count')
job_y

job_y['adesao'] = pd.Categorical(job_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (15,4))
sns.barplot(data = job_y, x='job', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesão por Emprego', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Emprego', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_emprego.png", dpi=300, facecolor='white', bbox_inches='tight')

contagem_total = df.groupby('job')['adesao'].count()
contagem_yes = df[df['adesao'] == 'yes'].groupby('job')['adesao'].count()

# Calcula a taxa de conversão
taxa_conversao = ((contagem_yes / contagem_total) * 100).fillna(0)
taxa_conversao

"""##### Adesão x Cliente com Crédito em Inadimplência"""

default_y = df.groupby(['default', 'adesao']).size().reset_index(name='count')
default_y

default_y['adesao'] = pd.Categorical(default_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (10,4))
sns.barplot(data = default_y, x='default', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesão por Cliente com Crédito em Inadimplência', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Cliente com Crédito em Inadimplência', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_credito_inadimplencia.png", dpi=300, facecolor='white', bbox_inches='tight')

"""##### Adesão x Cliente com Crédito à Habitação"""

housing_y = df.groupby(['housing', 'adesao']).size().reset_index(name='count')
housing_y

housing_y['adesao'] = pd.Categorical(housing_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (10,4))
sns.barplot(data = housing_y, x='housing', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesão por Cliente com Crédito à Habitação', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Cliente com Crédito à Habitação', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', bbox_to_anchor=(1.10, 1), fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_credito_habitacao.png", dpi=300, facecolor='white', bbox_inches='tight')

"""##### Adesão x Cliente com Empréstimo Pessoal"""

loan_y = df.groupby(['loan', 'adesao']).size().reset_index(name='count')
loan_y

loan_y['adesao'] = pd.Categorical(loan_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (10,4))
sns.barplot(data = loan_y, x='loan', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesão por Cliente com Empréstimo Pessoal', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Cliente com Empréstimo Pessoal', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_emprestimo_pessoal.png", dpi=300, facecolor='white', bbox_inches='tight')

"""##### Adesão x Último Mês de Contato do Ano"""

month_y = df.groupby(['month', 'adesao']).size().reset_index(name='count')
ordem_mes = ['mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec']
month_y['month'] = pd.Categorical(month_y['month'], categories = ordem_mes, ordered=True)
month_y = month_y.sort_values(['month', 'adesao'])
month_y

month_y['adesao'] = pd.Categorical(month_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (12,4))
sns.barplot(data = month_y, x='month', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesão de acordo com o último mês de contato do ano', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Último mês de contato do ano', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_mes_contato.png", dpi=300, facecolor='white', bbox_inches='tight')

contagem_total = df.groupby('month')['adesao'].count()
contagem_yes = df[df['adesao'] == 'yes'].groupby('month')['adesao'].count()

# Calcula a taxa de conversão
taxa_conversao = ((contagem_yes / contagem_total) * 100).fillna(0)
taxa_conversao.sort_values(ascending = False)

"""##### Adesão x Último Dia de Contato da Semana"""

day_of_week_y = df.groupby(['day_of_week', 'adesao']).size().reset_index(name='count')
ordem_semana = ['mon', 'tue', 'wed', 'thu', 'fri']
day_of_week_y['day_of_week'] = pd.Categorical(day_of_week_y['day_of_week'], categories = ordem_semana, ordered=True)
day_of_week_y = day_of_week_y.sort_values(['day_of_week', 'adesao'])
day_of_week_y

day_of_week_y['adesao'] = pd.Categorical(day_of_week_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (12,4))
sns.barplot(data = day_of_week_y, x='day_of_week', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesão de acordo com o último dia de contato da semana', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Último dia de contato da semana', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', bbox_to_anchor=(1.10, 1), fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_semana_contato.png", dpi=300, facecolor='white', bbox_inches='tight')

"""##### Adesão x Resultado da campanha de marketing anterior"""

poutcome_y = df.groupby(['poutcome', 'adesao']).size().reset_index(name='count')
poutcome_y

poutcome_y['adesao'] = pd.Categorical(poutcome_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (12,4))
sns.barplot(data = poutcome_y, x='poutcome', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesões de acordo com o resultado da campanha de marketing anterior', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Resultado da campanha de marketing anterior', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_campanha_anterior.png", dpi=300, facecolor='white', bbox_inches='tight')

"""##### Adesão x Quantidade de contatos realizados"""

campaign_y = df.groupby(['campaign', 'adesao']).size().reset_index(name='count')
campaign_y

"""> analisar resultados

##### Adesão x Número de contatos realizados antes da campanha para o cliente
"""

previous_y = df.groupby(['previous', 'adesao']).size().reset_index(name='count')
previous_y

previous_y['adesao'] = pd.Categorical(previous_y['adesao'], categories = ordem, ordered=True)
fig, ax = plt.subplots(figsize = (10,4))
sns.barplot(data = previous_y, x='previous', y='count', hue='adesao', palette = 'Oranges_r')
plt.title('Adesões de acordo com o número de contatos realizados \nantes da campanha para o cliente', fontsize = 18, style = "italic", loc = "center", pad = 15)
plt.xlabel('Número de contatos realizados antes da campanha para o cliente', fontsize = 12, style = "italic")
plt.ylabel('Adesão', fontsize = 12, style = "italic", labelpad = 12)
for container in ax.containers:
    ax.bar_label(container,size=8, label_type = 'edge', padding = 3)
legend = ax.legend(loc='upper right', fancybox=True, title = 'Aderiu?')
sns.despine(left=True, top = True)
plt.savefig(r"img\adesao_contatos_realizados.png", dpi=300, facecolor='white', bbox_inches='tight')

"""##### Adesão x Tipo de Comunicação x Duração Último Contato"""

fig = px.box(df, x="contact", y="duration", color = 'adesao', color_discrete_map = color_map)
fig.update_layout(
    title={
        'text': 'Adesão de acordo com o tipo de comunicação pela duração do último contato',
        'font': {
            'size': 16
        },
        'x': 0.5
    },
    legend_title_text='Aderiu?')
fig.write_html(r'img\adesao_tipo_comunicacao_ultimo_contato.html', include_plotlyjs='cdn')
fig.show()

"""## Machine Learning

### Importando as Bibliotecas
"""

from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, ConfusionMatrixDisplay, accuracy_score
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.preprocessing import LabelEncoder
from sklearn.impute import SimpleImputer
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from imblearn.under_sampling import RandomUnderSampler
from collections import Counter
from sklearn.decomposition import PCA
import numpy as np
from sklearn.naive_bayes import GaussianNB
from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier

"""### Definindo as variáveis"""

#variáveis preditoras
X = df.drop(['adesao', 'duration'], axis = 1)

X.shape

#variável-alvo
y = df['adesao']

y.shape

#dividindo os dados para treinamento e teste
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, stratify=y)

"""### Pre Processamento dos Dados"""

#colunas numéricas
numeric_cols = X_train.select_dtypes(include=['float', 'int']).columns
numeric_cols

#colunas categóricas
categorical_cols = X_train.select_dtypes(include=['object', 'bool']).columns
categorical_cols

#padronização dos valores numéricos
numeric_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='median')),
    ('scaler', StandardScaler())
])
numeric_transformer

#transformando colunas categóricas em numéricas
categorical_transformer = Pipeline(steps=[
    ('imputer', SimpleImputer(strategy='most_frequent')),
    ('encoder', OneHotEncoder())
])
categorical_transformer

preprocessor = ColumnTransformer(
    transformers=[
        ('num', numeric_transformer, numeric_cols),
        ('cat', categorical_transformer, categorical_cols)
    ])
preprocessor

#ajustando os dados de treinamento
X_train_preprocessed = preprocessor.fit_transform(X_train)

X_train_preprocessed

#ajustando os dados de teste
X_test_preprocessed = preprocessor.transform(X_test)

X_test_preprocessed

"""### Balanceamento dos Dados"""

print('Original dataset shape %s' % Counter(y))

#para balancear os dados utilizando Undersampling
undersampler = RandomUnderSampler(sampling_strategy='auto', random_state=42)

#balanceando os dados de treinamento
X_train_balanced, y_train_balanced = undersampler.fit_resample(X_train_preprocessed, y_train)
print("Contagem de classes após o undersampling:", Counter(y_train_balanced))

#balanceando os dados de teste
X_test_balanced, y_test_balanced = undersampler.fit_resample(X_test_preprocessed, y_test)
print("Contagem de classes após o undersampling:", Counter(y_test_balanced))

"""### PCA"""

pca = PCA(n_components = 21)
pca.fit(X_train_balanced)

# Obter a variância explicada acumulada
explained_variance = np.cumsum(pca.explained_variance_ratio_)

print("Variação explicada por cada componente principal:", explained_variance)

plt.plot(explained_variance, marker='o')
plt.xlabel('Número de Componentes Principais')
plt.ylabel('Variância Explicada Acumulada')
plt.title('Variância Explicada Acumulada pelo Número de Componentes Principais')
plt.grid(True)
plt.show()

pca = PCA(n_components = 7)
pca.fit(X_train_balanced)

# Obter a variância explicada acumulada
explained_variance = np.cumsum(pca.explained_variance_ratio_)

print("Variação explicada por cada componente principal:", explained_variance)

X_train_pca = pca.fit_transform(X_train_balanced)

X_test_pca = pca.transform(X_test_balanced)

"""### Função da Matriz de Confusão"""

#função para o mapa da matriz de confusão
def confusion_matrix_plot(clf, y_true, y_pred, title):
    cm = confusion_matrix(y_true, y_pred, normalize='true')
    fig, axs = plt.subplots(figsize=(8,8))
    acc = round(accuracy_score(y_true, y_pred), 2)
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=clf.classes_)
    axs.set_title('{} - acc {}'.format(title, acc))
    disp.plot(ax=axs, cmap='Oranges', colorbar=False)

"""### Modelos

#### Random Forest
"""

rf = RandomForestClassifier(random_state = 42)

"""*Sem undersampling*"""

rf.fit(X_train_preprocessed, y_train)

rf_preds = rf.predict(X_test_preprocessed)

rf_accuracy = accuracy_score(y_test, rf_preds)
rf_accuracy

confusion_matrix_plot(rf, y_test, rf_preds, 'Random Forest sem Undersampling')
plt.savefig("img\matriz_rf.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do Random Forest sem Undersampling:')
print(classification_report(y_test, rf_preds))

"""*Com Undersampling*"""

rf.fit(X_train_balanced, y_train_balanced)

us_rf_preds = rf.predict(X_test_balanced)

us_rf_accuracy = accuracy_score(y_test_balanced, us_rf_preds)
us_rf_accuracy

confusion_matrix_plot(rf, y_test_balanced, us_rf_preds, 'Random Forest')
plt.savefig("img\matriz_rf_us.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do Random Forest com Undersampling:')
print(classification_report(y_test_balanced, us_rf_preds))

"""*Com PCA*"""

rf.fit(X_train_pca, y_train_balanced)

us_rf_preds = rf.predict(X_test_pca)

us_rf_accuracy = accuracy_score(y_test_balanced, us_rf_preds)
us_rf_accuracy

confusion_matrix_plot(rf, y_test_balanced, us_rf_preds, 'Random Forest com PCA')
plt.savefig("img\matriz_rf_pca.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do Random Forest com PCA:')
print(classification_report(y_test_balanced, us_rf_preds))

"""#### Naive Bayes"""

nb = GaussianNB()

"""*Sem undersampling*"""

nb.fit(X_train_preprocessed, y_train)

nb_preds = nb.predict(X_test_preprocessed)

nb_accuracy = accuracy_score(y_test, nb_preds)
nb_accuracy

confusion_matrix_plot(nb, y_test, nb_preds, 'Naive Bayes sem Undersampling')
plt.savefig("img\matriz_nb.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do Naive Bayes sem Undersampling:')
print(classification_report(y_test, nb_preds))

"""*Com Undersampling*"""

nb.fit(X_train_balanced, y_train_balanced)

us_nb_preds = nb.predict(X_test_balanced)

us_nb_accuracy = accuracy_score(y_test_balanced, us_nb_preds)
us_nb_accuracy

confusion_matrix_plot(nb, y_test_balanced, us_nb_preds, 'Naive Bayes')
plt.savefig("img\matriz_nb_us.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do Naive Bayes com Undersampling:')
print(classification_report(y_test_balanced, us_nb_preds))

"""*Com PCA*"""

nb.fit(X_train_pca, y_train_balanced)

us_nb_preds = nb.predict(X_test_pca)

us_nb_accuracy = accuracy_score(y_test_balanced, us_nb_preds)
us_nb_accuracy

confusion_matrix_plot(nb, y_test_balanced, us_nb_preds, 'Naive Bayes com PCA')
plt.savefig("img\matriz_nb_pca.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do Naive Bayes com PCA:')
print(classification_report(y_test_balanced, us_nb_preds))

"""#### Decision Tree"""

dt = DecisionTreeClassifier(criterion='entropy', max_depth=4)

"""*Sem undersampling*"""

dt.fit(X_train_preprocessed, y_train)

dt_preds = dt.predict(X_test_preprocessed)

dt_accuracy = accuracy_score(y_test, dt_preds)
dt_accuracy

confusion_matrix_plot(dt, y_test, dt_preds, 'Decision Tree sem undersampling')
plt.savefig("img\matriz_dt.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report da Decision Tree sem Undersampling:')
print(classification_report(y_test, dt_preds))

"""*Com Undersampling*"""

dt.fit(X_train_balanced, y_train_balanced)

us_dt_preds = dt.predict(X_test_balanced)

us_dt_accuracy = accuracy_score(y_test_balanced, us_dt_preds)
us_dt_accuracy

confusion_matrix_plot(dt, y_test_balanced, us_dt_preds, 'Decision Tree')
plt.savefig("img\matriz_dt_us.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report da Decision Tree com Undersampling:')
print(classification_report(y_test_balanced, us_dt_preds))

"""*Com PCA*"""

dt.fit(X_train_pca, y_train_balanced)

us_dt_preds = dt.predict(X_test_pca)

us_dt_accuracy = accuracy_score(y_test_balanced, us_dt_preds)
us_dt_accuracy

confusion_matrix_plot(dt, y_test_balanced, us_dt_preds, 'Decision Tree com PCA')
plt.savefig("img\matriz_dt_pca.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report da Decision Tree com PCA:')
print(classification_report(y_test_balanced, us_dt_preds))

"""#### Logistic Regression"""

lr = LogisticRegression(max_iter=300)

"""*Sem undersampling*"""

lr.fit(X_train_preprocessed, y_train)

lr_preds = lr.predict(X_test_preprocessed)

lr_accuracy = accuracy_score(y_test, lr_preds)
lr_accuracy

confusion_matrix_plot(lr, y_test, lr_preds, 'Logistic Regression sem Undersampling')
plt.savefig("img\matriz_lr.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report da Logistic Regression sem Undersampling:')
print(classification_report(y_test, lr_preds))

"""*Com Undersampling*"""

lr.fit(X_train_balanced, y_train_balanced)

us_lr_preds = lr.predict(X_test_balanced)

us_lr_accuracy = accuracy_score(y_test_balanced, us_lr_preds)
us_lr_accuracy

confusion_matrix_plot(lr, y_test_balanced, us_lr_preds, 'Logistic Regression')
plt.savefig("img\matriz_lr_us.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report da Logistic Regression com Undersampling:')
print(classification_report(y_test_balanced, us_lr_preds))

"""*Com PCA*"""

lr.fit(X_train_pca, y_train_balanced)

us_lr_preds = lr.predict(X_test_pca)

us_lr_accuracy = accuracy_score(y_test_balanced, us_lr_preds)
us_lr_accuracy

confusion_matrix_plot(lr, y_test_balanced, us_lr_preds, 'Logistic Regression com PCA')
plt.savefig("img\matriz_lr_pca.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report da Logistic Regression com PCA:')
print(classification_report(y_test_balanced, us_lr_preds))

"""#### SVC"""

svc = SVC()

"""*Sem Oversampling*"""

svc.fit(X_train_preprocessed, y_train)

svc_preds = svc.predict(X_test_preprocessed)

svc_accuracy = accuracy_score(y_test, svc_preds)
svc_accuracy

confusion_matrix_plot(svc, y_test, svc_preds, 'SVC sem Undersampling')
plt.savefig("img\matriz_svc.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do SVC sem Undersampling:')
print(classification_report(y_test, svc_preds))

"""*Com Oversampling*"""

svc.fit(X_train_balanced, y_train_balanced)

us_svc_preds = svc.predict(X_test_balanced)

us_svc_accuracy = accuracy_score(y_test_balanced, us_svc_preds)
us_svc_accuracy

confusion_matrix_plot(svc, y_test_balanced, us_svc_preds, 'SVC')
plt.savefig("img\matriz_svc_us.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do SVC com Undersampling:')
print(classification_report(y_test_balanced, us_svc_preds))

"""*Com PCA*"""

svc.fit(X_train_pca, y_train_balanced)

us_svc_preds = svc.predict(X_test_pca)

us_svc_accuracy = accuracy_score(y_test_balanced, us_svc_preds)
us_svc_accuracy

confusion_matrix_plot(svc, y_test_balanced, us_svc_preds, 'SVC com PCA')
plt.savefig("img\matriz_svc_pca.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do SVC com PCA:')
print(classification_report(y_test_balanced, us_svc_preds))

"""#### KNN"""

knn = KNeighborsClassifier()

"""*Sem Oversampling*"""

knn.fit(X_train_preprocessed, y_train)

knn_preds = knn.predict(X_test_preprocessed)

knn_accuracy = accuracy_score(y_test, knn_preds)
knn_accuracy

confusion_matrix_plot(knn, y_test, knn_preds, 'KNN sem Undersampling')
plt.savefig("img\matriz_knn.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do KNN sem Undersampling:')
print(classification_report(y_test, knn_preds))

"""*Com Oversampling*"""

knn.fit(X_train_balanced, y_train_balanced)

us_knn_preds = knn.predict(X_test_balanced)

us_knn_accuracy = accuracy_score(y_test_balanced, us_knn_preds)
us_knn_accuracy

confusion_matrix_plot(knn, y_test_balanced, us_knn_preds, 'KNN')
plt.savefig("img\matriz_knn_us.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do KNN com Undersampling:')
print(classification_report(y_test_balanced, us_knn_preds))

"""*Com PCA*"""

knn.fit(X_train_pca, y_train_balanced)

us_knn_preds = knn.predict(X_test_pca)

us_knn_accuracy = accuracy_score(y_test_balanced, us_knn_preds)
us_knn_accuracy

confusion_matrix_plot(knn, y_test_balanced, us_knn_preds, 'KNN com PCA')
plt.savefig("img\matriz_knn_pca.png", dpi=300, facecolor='white', bbox_inches='tight')

print('Classification Report do KNN com PCA:')
print(classification_report(y_test_balanced, us_knn_preds))